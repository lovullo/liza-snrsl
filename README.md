# Structured Natural Rater Specification Language
<!--
  Copyright (C) 2017 R-T Specialty, LLC.

  This file is part of liza-snrsl.

  Copying and distribution of this file, with or without modification, are
  permitted in any medium without royalty provided the copyright notice and
  this notice are preserved.  This file is offered as-is, without warranty
  of any kind.
-->

This is a compiler written by RT Buffalo for a structured plain English
  (natural language) specification format used in certain rater
  specifications.
The grammar is semi-formal and hierarchical;
  this compiler was written to parse an _existing_, hand-written
    specification.
XML output is formatted for use in Liza and TAME,
  focused on UI generation.

This project was somewhat informally written in JavaScript as a
  proof-of-concept.
The implementation is therefore incomplete:
  it is useful for generating template XML that can then be manually
  modified and integrated into new or existing raters.
Future versions,
  should this format still be used,
    may benefit from support for mapping generated question ids to desired
    destination ids in the generated XML,
      for example.

It is not the goal of this project to be able to produce a functioning rater
  in a completely automated fashion---the
    Program XML format defined by Liza is intended to be easily
    human-readable and editable.
This specification language eases the development process by allowing
  specification writers to use a format of their choice without having to
  learn the formalities of our DSLs.

Further,
  it is not the intent of this project to generate rating calculations;
    such complexities are best left to the declarative metasyntax of TAME.

## Usage
To produce graph output for rendering with Graphviz (see below):

```sh
  $ ./bin/compile --graph input.csv > output.dot
```

To produce the generated XML grouped into sections:

```sh
  $ ./bin/compile --xml input.csv > output.xml
```

### Rendering Graph
Graph rendering is done using Graphviz.
You probably want to output to an SVG:

```sh
  $ dot -Tsvg output.dot > output.svg
```

You can render to a PNG,
  but its performance is pretty poor for large graphs.
If you already have the SVG,
  Inkscape does an excellent (performant) job rendering them,
    with good quality:

```sh
  $ inkscape -z -e output.png -w WIDTH_IN_PX output.svg
```

When showing the graph to others,
  it's probably a good idea to include both a PNG and the SVG---the
    former provides a more performant rendering of the overall graph but is
      unsuitable for any level of detail,
        and the latter can be zoomed in on infinitely.


### Question Map
Question identifiers are deterministically generated by truncating the hash
  of the question label;
    this produces incomprehensible ids.
To aid in their replacement,
  a question map can be used to map the generated ids to user-friendly ones:

```sh
  $ ./bin/compile --qmap path/to/qmap --xml input.csv > output.xml
```

The question map is simple key-value:

```json
{
  "q_a1b2c3": "friendly_name_a",
  "q_a2b3c4": "friendly_name_b"
}
```


## Input Format
Specifications are provided in Excel spreadsheets;
  they must be saved as CSVs for compilation.
This compiler takes a subset of that data:

1. A column entitled `"Class Code"`,
     which serves as a predicate for the entirety of the question set of that
     same row;
2. Class code description from the column `"Class(es) of Business"`; and
2. Question set columns,
     currently defined as `"Question Set"`, `"Question Set, continued"`, and
     `"Question Set, continued 2"`.

The concatenation of the three Question Set columns,
  in order,
  constitute the Question Set.


## Language Grammar
While a formal context-free grammar is possible,
  no attempt has been made to produce one,
    as inconsistencies in the specification format would make it extremely
    complex.
The grammar is informally defined in [SpecParser][] through a combination of
  recursive descent and regular expressions.

The grammar is extremely permissive and will tolerate
  inconsistencies---there
    are multiple ways to construct the same expression.

_TODO: Document grammar informally (spec structure)._


## Compiler Stack
The entire stack can be visualzed as a pipeline,
  where the final step depends on user-specified options:

```
  SpecParser           => Graph
    | SpecEvaluator    => Modified Graph
    | NodeXmlGenerator => XML-Augmented Graph
    | (GraphToDot => Graphviz File || XmlOutput => XML Templates)
```

The _parser_ [SpecParser][] is a combined lexer and parser
  (called a _scannerless parser_),
    transforming the structured language input into a graph.

Rather than using an abstract syntax tree (AST),
  which is later transformed into a graph,
  the parser immediately produces a graph.
A _graph_ is a data structure consisting of nodes and edges,
  and is represented by [Graph][],
  which is an aggressively indexed,
    trading memory for performance.

The graph is then evaluated by [SpecEvaluator][],
  which handles certain normalization and generation tasks like label
    processing; guessing question types; question id generation; and edge
    deduplication with unique predicate resolution.

This modified graph can then be used to generate XML templates;
  this task is handled by [NodeXmlGenerator][].
The output is added to the graph.

To visualize the output and examine its accuracy,
  a comprehensive visual graph is produced by [GraphToDot][].
The output format is the `dot` graph description language rendered by
  Graphviz.

Alternatively (in place of Graphviz output),
  the template XML can be output by [XmlOutput][].
This output can be pasted as-is into a rater,
  but should be manually modified for proper question ids and to handle
  aspects of the generation explicitly avoided by this compiler
    (for example, proper label generation by parsing English).

Viewed as a function of its input,
  the codomain is surjective:
    the compiler is deterministic and will always generate the same output
      for the same input,
        but different specifications may yield the same output because of
          grammar inconsistencies and row ordering.


[SpecParser]:       ./src/SpecParser.js
[Graph]:            ./src/Graph.js
[SpecEvaluator]:    ./src/SpecEvaluator.js
[NodeXmlGenerator]: ./src/NodeXmlGenerator.js
[GraphToDot]:       ./src/GraphToDot.js
[XmlOutput]:        ./src/XmlOutput.js


## License
liza-snrsl is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your option)
any later version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
more details.

The full license is available in `COPYING`.
